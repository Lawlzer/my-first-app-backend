import { ensureExists, getAllFiles, getFlag } from '@lawlzer/helpers';
import * as fs from 'fs';
import path from 'path';
import * as ts from 'typescript';

interface CustomInterface {
	path: string | undefined;
	originalName: string;
	newName: string; // Ideally this will be originalName, but it will be changed if there's a conflict.

	text: string;
}

function isInterfaceDeclaration(node: ts.Node): node is ts.InterfaceDeclaration {
	return node.kind === ts.SyntaxKind.InterfaceDeclaration;
}

function isTypeDeclaration(node: ts.Node): node is ts.TypeAliasDeclaration {
	return node.kind === ts.SyntaxKind.TypeAliasDeclaration;
}

function saveInterface(node: ts.InterfaceDeclaration | ts.TypeAliasDeclaration, foundInterfaces: CustomInterface[]) {
	const interfaceAlreadyExists = foundInterfaces.find((existingInterface) => existingInterface.text === node.getText());
	if (interfaceAlreadyExists) return;

	const customInterface: CustomInterface = {
		path: undefined,
		originalName: node.name.getText(),
		newName: node.name.getText(),
		text: node.getText(),
	};
	foundInterfaces.push(customInterface);
}

function recursiveInterface(checker: ts.TypeChecker, interfaceDeclaration: ts.InterfaceDeclaration | ts.TypeAliasDeclaration, foundInterfaces: CustomInterface[]) {
	saveInterface(interfaceDeclaration, foundInterfaces);
	const interfaceName = interfaceDeclaration.name.getText();

	const interfaceSymbol = checker.getSymbolAtLocation(interfaceDeclaration.name);
	if (!interfaceSymbol) throw new Error(`no symbol for interface: ${interfaceName}`);

	const interfaceType = checker.getDeclaredTypeOfSymbol(interfaceSymbol);
	const interfaceMembers = checker.getPropertiesOfType(interfaceType);

	interfaceMembers.map((member) => {
		if (!member.valueDeclaration) throw new Error(`no valueDeclaration for member: ${member.name}`);
		const myRealInterface = checker.getTypeOfSymbolAtLocation(member, member.valueDeclaration);
		const symbol = myRealInterface.getSymbol();
		if (!symbol) return;

		const declarations = symbol.getDeclarations();
		if (!declarations) throw new Error('no declarations found');

		declarations.map((declaration) => {
			if (isInterfaceDeclaration(declaration) || isTypeDeclaration(declaration)) {
				recursiveInterface(checker, declaration, foundInterfaces);
			}
		});
	});
}

/** Return only the used types from a given file */
function handleOneFile(inputPath: string, outputPath: string): void {
	// Build a program using the set of root file names in fileNames
	const program = ts.createProgram([inputPath], { target: ts.ScriptTarget.ES5, module: ts.ModuleKind.CommonJS });
	const checker = program.getTypeChecker(); // THIS IS THE KEY! This updates stuff to have type checking, I guess.

	const isMapFile = inputPath.endsWith('.map');
	if (isMapFile) return;

	// Visit every sourceFile in the program
	const sourceFile = program.getSourceFile(inputPath);
	if (!sourceFile) throw new Error(`Could not find source file: ${inputPath}`);

	const isPlainTypescriptFile = sourceFile.fileName.endsWith('.ts') && !sourceFile.isDeclarationFile;
	if (isPlainTypescriptFile) console.info("WARNING: This is a plain TypeScript file, not a Declaration file. If there are any absolute imports, there will be issues in the output. It's recommended that you pre-parse with TSC-alias, to avoid import issues.");

	const symbol = checker.getSymbolAtLocation(sourceFile);
	if (!symbol) throw new Error(`no symbol for sourceFile: ${sourceFile.fileName}`);

	let foundInterfaces: CustomInterface[] = [];
	sourceFile.statements.map((statement) => {
		const isGoodStatement = statement.kind === ts.SyntaxKind.InterfaceDeclaration || statement.kind === ts.SyntaxKind.TypeAliasDeclaration;
		if (!isGoodStatement) return;
		if (!isGoodStatement) throw new Error(`Statement is not an interface or type alias: ${statement.getText()}`);

		if (isInterfaceDeclaration(statement) || isTypeDeclaration(statement)) {
			recursiveInterface(checker, statement, foundInterfaces);
		}
	});

	let output = foundInterfaces
		.map((foundInterface) => {
			return `\n\n// filepath: ${foundInterface.path}\n// originalName: ${foundInterface.originalName}\n// newName: ${foundInterface.newName}\n${foundInterface.text} `;
		})
		.join('\n\n');

	output = `// This "types" file was automatically generated by the script "import-route-types.ts", which was created by Lawlzer.\n\n${output}`;
	fs.writeFileSync(outputPath, output);
	console.log(`Successfully wrote to file: ${outputPath}`);
}

(async () => {
	const pathToRoutes = path.resolve(getFlag('inputPath') as string);
	const outputPathRoutes = path.resolve(getFlag('outputPath') as string);

	const allRoutes = await getAllFiles(pathToRoutes);

	for await (const inputPath of allRoutes) {
		const outputPath = inputPath.replace(pathToRoutes, outputPathRoutes).replace('.d.ts', '.ts');

		await ensureExists(path.dirname(outputPath));
		handleOneFile(inputPath, outputPath);
	}
	console.log('Successfully generated all files!');
	process.exit(0);
})();
